import math

def reward_function(params):
    # Read input variables
    waypoints = params['waypoints']
    closest_waypoints = params['closest_waypoints']
    heading = params['heading']
    all_wheels_on_track = params['all_wheels_on_track']
    speed = params['speed']
    track_width = params['track_width']
    distance_from_center = params['distance_from_center']
    is_reversed = params['is_reversed']
    curvature = calculate_curvature(waypoints)

    # Initialize the reward with a typical value
    reward = 1.0

    # Penalize if the car is off track
    if not all_wheels_on_track:
        return 1e-4  # Minimum reward to discourage going off track

    # Penalize for being reversed
    if is_reversed:
        return 1e-2  # Low reward for going backward

    # Calculate the direction of the center line based on closest waypoints
    next_point = waypoints[closest_waypoints[1]]
    prev_point = waypoints[closest_waypoints[0]]

    # Calculate the direction in radians using atan2(dy, dx)
    track_direction = math.atan2(next_point[1] - prev_point[1], next_point[0] - prev_point[0])
    track_direction = math.degrees(track_direction)

    # Calculate the difference between the track direction and the car's heading
    direction_diff = abs(track_direction - heading)
    if direction_diff > 180:
        direction_diff = 360 - direction_diff

    # Penalize the reward if the direction difference is too large
    DIRECTION_THRESHOLD = 10.0
    if direction_diff > DIRECTION_THRESHOLD:
        reward *= 0.5

    # Reward for speed
    SPEED_THRESHOLD = 5.0  # Adjust this threshold as needed
    if curvature > 0.2:  # Sharp turn
        speed_threshold = SPEED_THRESHOLD * 0.4  # Slow down significantly
    else:
        speed_threshold = SPEED_THRESHOLD
    
    speed_reward = min(speed / speed_threshold, 1.0)
    reward *= speed_reward

    # Penalize for excessive steering
    steering = params['steering']
    STEERING_THRESHOLD = 10.0  # Adjust this threshold as needed
    if abs(steering) > STEERING_THRESHOLD:
        reward *= 0.7  # Larger penalty for high steering angles

    # Calculate the distance from the center of the track
    if distance_from_center > 0.3 * track_width:
        reward *= 0.5  # Stricter penalty for being far from the center
    else:
        reward *= 1.2  # Larger reward for staying near the center

    # Combined curvature handling
    if curvature:
        curvature_penalty = 1.0 / (1.0 + max(curvature))
        reward *= curvature_penalty

    return float(reward)

def calculate_curvature(waypoints):
    curvature_values = []
    for i in range(1, len(waypoints) - 1):
        p1 = waypoints[i - 1]
        p2 = waypoints[i]
        p3 = waypoints[i + 1]

        # Calculate distances and angles
        d1 = distance(p1, p2)
        d2 = distance(p2, p3)
        angle = calculate_angle(p1, p2, p3)

        # Calculate radius of curvature
        radius_of_curvature = (d1 * d2 * math.sin(angle)) / (4 * abs(d1 - d2)) if d1 != d2 else float('inf')

        # Calculate curvature
        curvature = 1 / radius_of_curvature if radius_of_curvature != 0 else 0
        curvature_values.append(curvature)

    return curvature_values

def distance(p1, p2):
    dx = p2[0] - p1[0]
    dy = p2[1] - p1[1]
    return math.sqrt(dx**2 + dy**2)

def calculate_angle(p1, p2, p3):
    v1 = (p2[0] - p1[0], p2[1] - p1[1])
    v2 = (p3[0] - p2[0], p3[1] - p2[1])

    dot_product = v1[0] * v2[0] + v1[1] * v2[1]
    mag_v1 = math.sqrt(v1[0]**2 + v1[1]**2)
    mag_v2 = math.sqrt(v2[0]**2 + v2[1]**2)

    angle = math.acos(dot_product / (mag_v1 * mag_v2)) if mag_v1 and mag_v2 else 0
    return angle
